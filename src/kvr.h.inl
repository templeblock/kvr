///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Copyright (c) 2015 Ubaka Onyechi
 *
 * kvr is free software distributed under the MIT license.
 * See https://raw.githubusercontent.com/uonyx/kvr/master/LICENSE for details.
 */

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef KVR_H_INL
#define KVR_H_INL

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

namespace kvr
{
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline kvr::key::key (char *str, sz_t len) : m_str (str), m_len (len), m_ref (1)
  {
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline const char *key::get_string () const
  {
    return m_str;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline sz_t key::get_length () const
  {
    return m_len;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline kvr::value::value (kvr::ctx *ctx, uint32_t flags) : m_flags (flags), m_ctx (ctx)
  {
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::is_null () const
  {
    return (m_flags & FLAG_TYPE_NULL) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::is_map () const
  {
    return (m_flags & FLAG_TYPE_MAP) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::is_array () const
  {
    return (m_flags & FLAG_TYPE_ARRAY) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::is_string () const
  {
    return (m_flags & (FLAG_TYPE_STRING_DYNAMIC | FLAG_TYPE_STRING_STATIC)) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::is_boolean () const
  {
    return (m_flags & FLAG_TYPE_BOOLEAN) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::is_integer () const
  {
    return (m_flags & FLAG_TYPE_NUMBER_INTEGER) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::is_float () const
  {
    return (m_flags & FLAG_TYPE_NUMBER_FLOAT) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::_is_string_dynamic () const
  {
    return (m_flags & FLAG_TYPE_STRING_DYNAMIC) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::_is_string_static () const
  {
    return (m_flags & FLAG_TYPE_STRING_STATIC) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool value::_is_number () const
  {
    return (m_flags & (FLAG_TYPE_NUMBER_INTEGER | FLAG_TYPE_NUMBER_FLOAT)) != 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline key * pair::get_key () const
  {
    return m_k;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline pair::pair () : m_k (NULL), m_v (NULL) 
  {
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline value * pair::get_value ()
  {
    return m_v;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline obuffer::obuffer (size_t size, allocator *alloc) : m_stream (size, alloc)
  {
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline obuffer::obuffer (uint8_t *data, size_t size, allocator *alloc) : m_stream (data, size, alloc)
  {
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline const uint8_t * obuffer::get_data () const
  {
    return m_stream.buffer ();
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline size_t obuffer::get_size () const
  {
    return m_stream.tell ();
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline void ctx::val_store::init (size_t cap, allocator *a)
  {
    m_data = (value **) a->allocate (sizeof (value *) * cap);
    m_size = cap;
    m_ulen = 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline void ctx::val_store::deinit (allocator *a)
  {
    a->deallocate (m_data, (sizeof (value *) * m_size));
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline void ctx::val_store::push_back (value *v, allocator *a)
  {
    if (m_ulen >= m_size)
    {
      size_t new_sz = m_size + m_size;
      value **new_data = (value **) a->allocate (sizeof (value *) * new_sz);
      memcpy (new_data, m_data, sizeof (value *) * m_size);
      a->deallocate (m_data, m_size);
      m_data = new_data;
      m_size = new_sz;
    }

    m_data [m_ulen++] = v;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline void ctx::val_store::remove (value *v)
  {
    for (size_t i = m_ulen; i >= 1; --i)
    {
      size_t s = i - 1;
      if (m_data [s] == v)
      {
        //m_data [s] = NULL; // m_len will be resized during this->resize ()
        for (size_t j = s + 1; j < m_ulen; ++j)
        {
          m_data [j - 1] = m_data [j];
        }
        m_data [--m_ulen] = NULL;
        break;
      }
    }
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline size_t ctx::val_store::size () const
  {
    return m_ulen;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline value * ctx::val_store::at (size_t index)
  {
    return m_data [index];
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline void ctx::val_store::clear ()
  {
    memset (m_data, 0, sizeof (value *) * m_size);
    m_ulen = 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline bool ctx::equal_cstr::operator() (const char *a, const char *b) const
  {
    return std::strcmp (a, b) == 0;
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////

  inline uint32_t ctx::hash_djb::operator() (const char *s) const
  {
    uint32_t hash = 5381;
    char c;
    while ((c = *s++) != 0)
    {
      hash = ((hash << 5) + hash) + c;
    }
    return hash;
  }
}

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
