/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

#include "kvr.h"
#include <assert.h>

#define KVR_SAFE_ASSERT_ON                1

#if 1 // debug
#define KVR_ASSERT(X) assert(X)
#else
#if KVR_SAFE_ASSERT_ON
#define KVR_ASSERT(X) do { if (!X) { return; } } while (0) // can't just return void in all funcs
#else
#define KVR_ASSERT(X) (void)(X)
#endif
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

#if defined (_MSC_VER)
#define kvr_strcpy(dst, src, sz) strcpy_s(dst, sz, src)
#define kvr_strdup(src, sz) _strdup(src)
#else
#define kvr_strcpy(dst, src, sz) { strncpy (dst, src, sz); dst [sz - 1] = 0; }
#define kvr_strdup(src, sz) strndup (src, sz)
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::pair
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair::pair () : m_k (NULL), m_v (NULL) 
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair::~pair () 
{ 
  m_k = NULL; 
  m_v = NULL; 
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char *kvr::pair::get_key () const
{
  KVR_ASSERT (m_k);

  const char *keystr = m_k ? m_k->get_string () : NULL;

  return keystr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::pair::get_value ()
{
  KVR_ASSERT (m_v);

  value *v = m_v;

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::Key
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key::key (const char *str) : m_ref (1)
{
  size_t sz = strlen (str) + 1;
  m_str = new char [sz];  

  kvr_strcpy (m_str, str, sz);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key::~key ()
{
  delete [] m_str;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char *kvr::key::get_string () const
{
  return m_str;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::init (sz_t size)
{
  m_ptr = new value * [size];
  memset (m_ptr, 0, sizeof (kvr::value *) * size); // debug-only
  m_cap = size;
  m_len = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::deinit ()
{
  KVR_ASSERT (m_ptr);
  delete [] m_ptr;
  m_ptr = NULL;
  //return (void) 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::push (value *v)
{
  KVR_ASSERT (v);

  if (m_len >= m_cap)
  {
    // resize
    sz_t newCap = m_cap + SIZE_INCR_ARRAY;
    value ** newPtr = new value * [newCap];
    memset (newPtr, 0, sizeof (kvr::value *) * newCap); // debug-only
    memcpy (newPtr, m_ptr, sizeof (kvr::value *) * m_len);
    delete [] m_ptr;

    m_ptr = newPtr;
    m_cap = newCap;
  }

  this->m_ptr [m_len++] = v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value *kvr::value::array::pop ()
{
  value *v = NULL;
  
  if (m_len)
  {
    v = m_ptr [m_len--];
  }  

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::map
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::map::init (sz_t size)
{
  m_ptr = new pair [size];
  m_cap = size;
  m_size = 0;  
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::map::deinit ()
{
  delete [] m_ptr;
  m_ptr = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair *kvr::value::map::insert (key *k, value *v)
{
  KVR_ASSERT (k);
  KVR_ASSERT (v);

  if (m_size >= m_cap)
  {
    // resize
    sz_t newCap = m_cap + SIZE_INCR_MAP;
    pair *newPtr = new pair [newCap];
    memcpy (newPtr, m_ptr, sizeof (pair) * m_cap);
    delete [] m_ptr;

    m_ptr = newPtr;
    m_cap = newCap;
  }

  pair *p = &m_ptr [m_size++];

  p->m_k = k;
  p->m_v = v;

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::map::remove (pair *p)
{
  KVR_ASSERT (p);
  KVR_ASSERT (p->m_k);
  KVR_ASSERT (p->m_v);

  bool rm = false;

#if KVR_OPTIMIZATION_FAST_MAP_REMOVE_ON 
  p->m_k = NULL;
  p->m_v = NULL;

  m_size--;
  rm = true;
#else
  for (sz_t i = 0, c = m_cap; i < c; ++i)
  {
    pair *pp = &m_ptr [i];
    if ((pp == p) && pp->m_k)
    {
      KVR_ASSERT (pp->m_v);
      
      p->m_k = NULL;
      p->m_v = NULL;

      m_size--;
      rm = true;

      break;
    }
  }
#endif
  
  return rm;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair *kvr::value::map::find (const key *k) const
{
  KVR_ASSERT (k);

  pair *p = NULL;

  for (sz_t i = 0, c = m_cap; i < c; ++i)
  {
    pair *pp = &m_ptr [i];

#if 0 // implicitly checked in next 'if' as k cannot be null
    if (!pp->m_k)
    {
      continue;
    }
#endif    

    if (pp->m_k == k)
    {
      KVR_ASSERT (pp->m_v);
      p = pp;
      break;
    }
  }

  return p;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::map::cursor
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::cursor::get_pair ()
{
#if 0
  pair *p = NULL;

  if (m_index < m_map->m_cap)
  {
    p = &m_map->m_ptr [m_index++];

    while (p && !p->m_k)
    {
      p = (m_index < m_map->m_cap) ? &m_map->m_ptr [m_index++] : NULL;
    }
  }
#else
  pair dummy;
  pair *p = &dummy;

  while (p && !p->m_k)
  {
    p = (m_index < m_map->m_cap) ? &m_map->m_ptr [m_index++] : NULL;
  }
#endif

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr * kvr::init (uint32_t flags)
{
  kvr *ctx = new kvr ();

  return ctx;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::deinit (kvr *ctx)
{
  delete ctx;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::kvr ()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::~kvr ()
{
#if 0
  KVR_ASSERT (m_keystore.empty ());
#else
  // clean up left-over keys
  keystore::iterator iter = m_keystore.begin ();  
  while (iter != m_keystore.end ())
  {
    key *k = (*iter).second;
    KVR_ASSERT (k);
    delete k;

    m_keystore.erase (iter);
    iter = m_keystore.begin ();
  }
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value_null ()
{
  value *v = _create_value_null (VALUE_FLAG_PARENT_CTX);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value_map ()
{
  value *v = _create_value_map (VALUE_FLAG_PARENT_CTX);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value_array ()
{
  value *v = _create_value_array (VALUE_FLAG_PARENT_CTX);
  
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (int64_t number)
{
  value *v = _create_value (VALUE_FLAG_PARENT_CTX, number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (double number)
{
  value *v = _create_value (VALUE_FLAG_PARENT_CTX, number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (bool boolean)
{
  value *v = _create_value (VALUE_FLAG_PARENT_CTX, boolean);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (const char *str)
{
  value *v = _create_value (VALUE_FLAG_PARENT_CTX, str);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::destroy_value (value *v)
{
  _destroy_value (VALUE_FLAG_PARENT_CTX, v);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value_null (uint32_t parentType)
{
  value *v = new value (parentType, this);

  v->conv_null ();

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value_map (uint32_t parentType, sz_t size)
{
  value *v = new value (parentType, this);

  v->conv_map ();

  v->m_data.m.init (size);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value_array (uint32_t parentType, sz_t size)
{
  value *v = new value (parentType, this);

  v->conv_array ();

  v->m_data.a.init (size);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value (uint32_t parentType, int64_t number)
{
  value *v = new value (parentType, this);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_number_i ();
#endif

  v->set_number_i (number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////


kvr::value * kvr::_create_value (uint32_t parentType, double number)
{
  value *v = new value (parentType, this);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_number_f ();
#endif

  v->set_number_f (number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value (uint32_t parentType, bool boolean)
{
  value *v = new value (parentType, this);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_boolean ();
#endif

  v->set_boolean (boolean);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value (uint32_t parentType, const char *str)
{
  value *v = new value (parentType, this);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_string ();
#endif
  v->set_string (str);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::_destroy_value (uint32_t parentType, value *v)
{
  KVR_ASSERT (v);
  KVR_ASSERT ((v->m_flags & parentType) != 0);
  
  delete v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key * kvr::find_key (const char *str)
{
  KVR_ASSERT (str);

  key *k = NULL;

  keystore::iterator iter = m_keystore.find (str);
  if (iter != m_keystore.end ())
  {
    k = (*iter).second;
  }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key * kvr::create_key (const char *str)
{
  KVR_ASSERT (str);

  key *k = NULL;

  keystore::iterator iter = m_keystore.find (str);
  if (iter != m_keystore.end ())
  {
    k = (*iter).second;
    k->m_ref++;
  }
  else
  {
    k = new key (str);
    std::pair<const char *, key *> p (k->m_str, k);
    bool s = m_keystore.insert (p).second;
    KVR_ASSERT (s);
  }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::destroy_key (key *k)
{
  KVR_ASSERT (k);

  if ((--k->m_ref) == 0)
  {
    m_keystore.erase (k->m_str);
    delete k;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::value (uint32_t flags, kvr *ctx) : m_flags (flags), m_ctx (ctx) 
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::~value () 
{
  this->clear (); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_null ()
{
  if (!is_null ())
  {
    clear ();
    m_flags |= VALUE_FLAG_TYPE_NULL;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_map ()
{
  if (!is_map ())
  {
    clear ();    
    m_flags |= VALUE_FLAG_TYPE_MAP;    
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_array ()
{
  if (!is_array ())
  {
    clear ();
    m_flags |= VALUE_FLAG_TYPE_ARRAY;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_string ()
{
  if (!is_string ())
  {
    clear ();
    m_flags |= VALUE_FLAG_TYPE_STT_STRING;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_boolean ()
{
  if (!is_boolean ())
  {
    clear ();
    m_flags |= VALUE_FLAG_TYPE_BOOLEAN;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_number_i ()
{
  if (!is_number_integer ())
  {
    clear ();
    m_flags |= VALUE_FLAG_TYPE_NUMBER_INTEGER;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_number_f ()
{
  if (!is_number_float ())
  {
    clear ();
    m_flags |= VALUE_FLAG_TYPE_NUMBER_FLOAT;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////


void kvr::value::set_string (const char *str)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_string ());
#else
  conv_string ();
#endif
  // assert null or string

  kvr::sz_t len = (kvr::sz_t) strlen (str);
  kvr::sz_t cap = string::stt_str::CAP;

  bool isThisStatic = !is_string_dynamic () && (len < cap);
  if (isThisStatic)
  {
    m_flags |= VALUE_FLAG_TYPE_STT_STRING;    
    kvr_strcpy (m_data.s.stt.data, str, cap);
    //m_data.s.stt.data [cap - 1] = 0;
  }
  else
  {
    m_flags |= VALUE_FLAG_TYPE_DYN_STRING;
    m_data.s.dyn.data = kvr_strdup (str, len);
    m_data.s.dyn.size = len;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_boolean (bool b)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_boolean ());
#else
  conv_boolean ();
#endif
  
  m_data.b = b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_number_i (int64_t n)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_number_integer ());
#else  
  conv_number_i ();
#endif

  m_data.n.i = n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_number_f (double n)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_number_float ());
#else  
  conv_number_f ();
#endif

  m_data.n.f = n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char * kvr::value::get_string () const
{
  KVR_ASSERT (is_string ());
  return is_string_dynamic () ? m_data.s.dyn.data : m_data.s.stt.data;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::get_boolean () const
{
  KVR_ASSERT (is_boolean ());
  return m_data.b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

int64_t kvr::value::get_number_i () const
{
  KVR_ASSERT (is_number ());
  return is_number_integer () ? m_data.n.i : (int64_t) m_data.n.f;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

double kvr::value::get_number_f () const
{
  KVR_ASSERT (is_number ());
  return is_number_float () ? m_data.n.f : (double) m_data.n.i;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::size () const
{
  KVR_ASSERT (is_array () || is_map ());

  sz_t size = 0;

  if (is_array ())
  {
    size = this->m_data.a.m_len;
  }
  else if (is_map ())
  {
    size = this->m_data.m.m_size;
  }

  return size;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (int64_t number)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else  
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, number);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (double number)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_array ());
#else
  conv_array ();  
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, number);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (bool boolean)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else  
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, boolean);  
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (const char *str)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  conv_array ();  
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, str);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_map ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_map (VALUE_FLAG_PARENT_ARRAY);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_array ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_array (VALUE_FLAG_PARENT_ARRAY);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_null ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_null (VALUE_FLAG_PARENT_ARRAY);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::pop ()
{
  KVR_ASSERT (is_array ());

  bool ret = false;

  kvr::value *v = this->m_data.a.pop ();
  if (v)
  {
    m_ctx->_destroy_value (VALUE_FLAG_PARENT_ARRAY, v);
    ret = true;
  }

  return ret;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::element (kvr::sz_t index) const
{
  KVR_ASSERT (is_array ());

  value *v = this->m_data.a.m_ptr [index];

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, int64_t number)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    p->m_v->set_number_i (number);
    m_ctx->destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, number);
    KVR_ASSERT (v);
    p = this->m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, double number)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());  
#else
  conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    p->m_v->set_number_f (number);
    m_ctx->destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, number);
    KVR_ASSERT (v);
    p = this->m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, bool boolean)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    p->m_v->set_boolean (boolean);
    m_ctx->destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, boolean);
    KVR_ASSERT (v);
    p = this->m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, const char *str)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);  
  if (p)
  {
    p->m_v->set_string (str);
    m_ctx->destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, str);
    KVR_ASSERT (v);
    p = this->m_data.m.insert (k, v);    
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert_map (const char *keystr)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    m_ctx->destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value_map (VALUE_FLAG_PARENT_MAP);
    KVR_ASSERT (v);
    p = this->m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert_array (const char *keystr)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    m_ctx->destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value_array (VALUE_FLAG_PARENT_MAP);
    KVR_ASSERT (v);
    p = this->m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert_null (const char *keystr)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    m_ctx->destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value_null (VALUE_FLAG_PARENT_MAP);
    KVR_ASSERT (v);
    p = this->m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::remove (kvr::pair *pair)
{
  KVR_ASSERT (is_map ());

  bool rm = false;

  key *k = pair->m_k;
  value *v = pair->m_v;

  if (m_data.m.remove (pair)) // mark k,v as null
  {
    m_ctx->destroy_key (k);

    m_ctx->_destroy_value (VALUE_FLAG_PARENT_MAP, v);

    rm = true;
  }

  return rm;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::find (const char *keyStr) const
{
  KVR_ASSERT (is_map ());

  pair *p = NULL;

  key *k = m_ctx->find_key (keyStr);

  if (k)
  {
    p = this->m_data.m.find (k);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::cursor kvr::value::fcursor () const
{
  KVR_ASSERT (is_map ());
  
  return cursor (&m_data.m);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::copy (const value *rhs)
{
  KVR_ASSERT (rhs);

  this->clear ();

  // recursively iterate through rhs and copy to this
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::clear ()
{
  // release memory
  if (is_map ())
  {
    cursor c = fcursor ();
    pair *p = c.get_pair ();
    while (p)
    {
      m_ctx->destroy_key (p->m_k);
      m_ctx->_destroy_value (VALUE_FLAG_PARENT_MAP, p->m_v);
      p = c.get_pair ();
    }    
    m_data.m.deinit ();
  }
  else if (is_array ())
  {
    sz_t c = this->size ();
    while (c)
    {
      this->pop ();
      c = this->size ();
    }
    m_data.a.deinit ();
  }
  else if (is_string_dynamic ())
  {  
    free ((void *) m_data.s.dyn.data);
  }

  // zero data
  memset (&m_data, 0, sizeof (m_data));

  // clear type flag
  const uint32_t typeFlagsMask = 0xffffff00;
  m_flags &= typeFlagsMask;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::search (const char **path, sz_t pathLen)
{
  KVR_ASSERT (path);

  value *v = (pathLen > 0) ? this : NULL;
  
  sz_t pc = 0; 

  while (v && (pc < pathLen))
  {
    const char *key = path [pc++];

    if (v->is_array ())
    {
      char k0 = key [0];

      switch (k0)
      {
        case '*': // reserved for basic pattern matching
        {
          v = NULL;
          break;
        }

        default: 
        {
          sz_t ki = (sz_t) atoi (key);
          v = v->element (ki);
          break;
        }
      }
    }
    else if (v->is_map ())
    {
      pair *p = v->find (key);
      v = p ? p->get_value () : NULL;
    }
  }
  
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
