/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

#include "kvr.h"
#include <assert.h>

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

#define KVR_SAFE_ASSERT_ON                1
#if KVR_DEBUG
#define KVR_ASSERT(X) assert(X)
#else
#if KVR_SAFE_ASSERT_ON
#define KVR_ASSERT(X) do { if (!X) { return; } } while (0) // dumb: can't just return void in all funcs
#else
#define KVR_ASSERT(X) (void)(X)
#endif
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

#if defined (_MSC_VER)
#define kvr_strcpy(dst, dsz, src) strcpy_s (dst, dsz, src)
#define kvr_strncpy(dst, src, n) strncpy_s (dst, src, n)
#define kvr_strdup(src, sz) _strdup (src)
#else
#define kvr_strcpy(dst, dsz, src) { strncpy (dst, src, dsz); dst [sz - 1] = 0; }
#define kvr_strncpy(dst, src, n) strncpy (dst, src, n)
#define kvr_strdup(src, sz) strndup (src, sz)
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::Key
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key::key (const char *str, bool dcopy) : m_ref (1)
{
  KVR_ASSERT (str);

  if (dcopy)
  {
    size_t sz = strlen (str) + 1;
    m_str = new char [sz];
    kvr_strcpy (m_str, sz, str);
  }
  else
  {
    m_str = const_cast<char *> (str);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key::~key ()
{
  delete [] m_str;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char *kvr::key::get_string () const
{
  return m_str;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::init (sz_t size)
{
  KVR_ASSERT (size > 0);

  sz_t allocsz = (size + (CAP_INCR - 1)) & ~(CAP_INCR - 1);
  m_ptr = new value * [allocsz];
#if KVR_DEBUG
  memset (m_ptr, 0, sizeof (kvr::value *) * allocsz); // debug-only
#endif
  m_cap = allocsz;
  m_len = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::deinit ()
{
  KVR_ASSERT (m_ptr);
  delete [] m_ptr;
  m_ptr = NULL;
  //return (void) 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::array::push (value *v)
{
  KVR_ASSERT (v);

  if (m_len >= m_cap)
  {
    KVR_ASSERT (m_ptr);

    // resize
    sz_t newCap = m_cap + CAP_INCR;
    value ** newPtr = new value * [newCap];
#if KVR_DEBUG
    memset (newPtr, 0, sizeof (kvr::value *) * newCap); 
#endif
    memcpy (newPtr, m_ptr, sizeof (kvr::value *) * m_len);
    delete [] m_ptr;

    m_ptr = newPtr;
    m_cap = newCap;
  }

  m_ptr [m_len++] = v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value *kvr::value::array::pop ()
{
#if KVR_DEBUG
  value *v = NULL;
  if (m_len > 0)
  {
    v = m_ptr [--m_len];
    m_ptr [m_len] = NULL;
  }
#else
  value *v = (m_len > 0) ? m_ptr [--m_len] : NULL;
#endif

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::map
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::map::init (sz_t size)
{
  KVR_ASSERT (size > 0);

  sz_t allocsz = (size + (CAP_INCR - 1)) & ~(CAP_INCR - 1);
  m_ptr = new pair [allocsz];
  m_cap = allocsz;
  m_size = 0;  
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::map::deinit ()
{
  delete [] m_ptr;
  m_ptr = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair *kvr::value::map::insert (key *k, value *v)
{
  KVR_ASSERT (k);
  KVR_ASSERT (v);

  if (m_size >= m_cap)
  {
    KVR_ASSERT (m_ptr);

    // resize
    sz_t newCap = m_cap + CAP_INCR;
    pair *newPtr = new pair [newCap];
    memcpy (newPtr, m_ptr, sizeof (pair) * m_cap);
    delete [] m_ptr;

    m_ptr = newPtr;
    m_cap = newCap;
  }

  pair *p = &m_ptr [m_size++];

  p->m_k = k;
  p->m_v = v;

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::map::remove (pair *p)
{
  KVR_ASSERT (p);
  KVR_ASSERT (p->m_k);
  KVR_ASSERT (p->m_v);

  bool rm = false;

  if (m_size > 0)
  {
#if KVR_OPTIMIZATION_FAST_MAP_REMOVE_ON 
    p->m_k = NULL;
    p->m_v = NULL;

    m_size--;
    rm = true;
#else
    for (sz_t i = 0, c = m_cap; i < c; ++i)
    {
      pair *pp = &m_ptr [i];
      if ((pp == p) && pp->m_k)
      {
        KVR_ASSERT (pp->m_v);

        p->m_k = NULL;
        p->m_v = NULL;

        m_size--;
        rm = true;

        break;
      }
    }
#endif
  }
  
  return rm;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair *kvr::value::map::find (const key *k) const
{
  KVR_ASSERT (k);

  pair *p = NULL;

  for (sz_t i = 0, c = m_cap; i < c; ++i)
  {
    pair *pp = &m_ptr [i];

#if 0 // implicitly checked in next 'if' as k should not be null
    if (!pp->m_k)
    {
      continue;
    }
#endif    

    if (pp->m_k == k)
    {
      KVR_ASSERT (pp->m_v);
      p = pp;
      break;
    }
  }

  return p;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value::map::cursor
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::cursor::get_pair ()
{
#if 0
  pair *p = NULL;

  if (m_index < m_map->m_cap)
  {
    p = &m_map->m_ptr [m_index++];

    while (p && !p->m_k)
    {
      p = (m_index < m_map->m_cap) ? &m_map->m_ptr [m_index++] : NULL;
    }
  }
#else
  pair dummy;
  pair *p = &dummy;

  while (p && !p->m_k)
  {
    p = (m_index < m_map->m_cap) ? &m_map->m_ptr [m_index++] : NULL;
  }
#endif

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr * kvr::init (uint32_t flags)
{
  kvr *ctx = new kvr ();

  return ctx;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::deinit (kvr *ctx)
{
  KVR_ASSERT (ctx);

  delete ctx;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::kvr ()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::~kvr ()
{
#if KVR_DEBUG
  KVR_ASSERT (m_keystore.empty ());
#else
  // clean up left-over keys
  keystore::iterator iter = m_keystore.begin ();  
  while (iter != m_keystore.end ())
  {
    key *k = (*iter).second;
    KVR_ASSERT (k);
    delete k;

    m_keystore.erase (iter);
    iter = m_keystore.begin ();
  }
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value_null ()
{
  value *v = this->_create_value_null (VALUE_FLAG_PARENT_CTX);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value_map ()
{
  value *v = this->_create_value_map (VALUE_FLAG_PARENT_CTX);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value_array ()
{
  value *v = this->_create_value_array (VALUE_FLAG_PARENT_CTX);
  
  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (int64_t number)
{
  value *v = this->_create_value (VALUE_FLAG_PARENT_CTX, number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (double number)
{
  value *v = this->_create_value (VALUE_FLAG_PARENT_CTX, number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (bool boolean)
{
  value *v = this->_create_value (VALUE_FLAG_PARENT_CTX, boolean);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::create_value (const char *str)
{
  value *v = this->_create_value (VALUE_FLAG_PARENT_CTX, str);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::destroy_value (value *v)
{
  this->_destroy_value (VALUE_FLAG_PARENT_CTX, v);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::diff (const value *original, const value *modified)
{
  KVR_ASSERT (original);
  KVR_ASSERT (modified);

  value *vout = NULL;

  const value *og = original;
  const value *md = modified;

  if (og && md && (og != md) && (og->_type () == md->_type ()))
  {
    //////////////////////////////////
    if (og->is_map () || og->is_array ())
    //////////////////////////////////
    {
      vout = this->_create_value_map (VALUE_FLAG_PARENT_CTX);

      pair *set = vout->insert_map ("set");
      pair *add = vout->insert_map ("add");
      pair *rem = vout->insert_array ("rem");

      const char * path [KVR_CONSTANT_MAX_TREE_DEPTH];

#if KVR_DEBUG
      memset (path, 0, sizeof (path));
#endif
      this->_diff_set (set->get_value (), rem->get_value (), og, md, path, KVR_CONSTANT_MAX_TREE_DEPTH, 0);

#if KVR_DEBUG
      memset (path, 0, sizeof (path));
#endif
      this->_diff_add (add->get_value (), og, md, path, KVR_CONSTANT_MAX_TREE_DEPTH, 0);
    }
    
    //////////////////////////////////
    else if (og->is_string ())
    //////////////////////////////////
    {
      const char *ogstr = og->get_string ();
      const char *mdstr = md->get_string ();

      if (strcmp (ogstr, mdstr) != 0)
      {
        vout = this->_create_value (VALUE_FLAG_PARENT_CTX, mdstr);
      }
    }

    //////////////////////////////////
    else if (og->_is_number_integer ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_number ());

      if (md->_is_number_integer ())
      {
        int64_t ogn = og->get_number_i ();
        int64_t mdn = md->get_number_i ();

        if (ogn != mdn)
        {
          vout = this->_create_value (VALUE_FLAG_PARENT_CTX, mdn);
        }
      }
      else if (md->_is_number_float ())
      {
        double ogn = og->get_number_f ();
        double mdn = md->get_number_f ();

        if (fabs (ogn - mdn) > KVR_CONSTANT_ZERO_TOLERANCE)
        {
          vout = this->_create_value (VALUE_FLAG_PARENT_CTX, mdn);
        }
      }
    }

    //////////////////////////////////
    else if (og->_is_number_float ())
    //////////////////////////////////
    {
      double ogn = og->get_number_f ();
      double mdn = md->get_number_f ();

      if (fabs (ogn - mdn) > KVR_CONSTANT_ZERO_TOLERANCE)
      {
        vout = this->_create_value (VALUE_FLAG_PARENT_CTX, mdn);
      }
    }

    //////////////////////////////////
    else if (og->is_boolean ())
    //////////////////////////////////
    {
      bool ogb = og->get_boolean ();
      bool mdb = md->get_boolean ();

      if (ogb != mdb)
      {
        vout = this->_create_value (VALUE_FLAG_PARENT_CTX, mdb);
      }
    }
  }

  return vout;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key * kvr::_find_key (const char *str)
{
  KVR_ASSERT (str);

  key *k = NULL;

  keystore::iterator iter = m_keystore.find (str);
  if (iter != m_keystore.end ())
  {
    k = (*iter).second;
  }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::key * kvr::_create_key (const char *str, bool dcopy)
{
  KVR_ASSERT (str);

  key *k = NULL;

  keystore::iterator iter = m_keystore.find (str);
  if (iter != m_keystore.end ())
  {
    k = (*iter).second;
    k->m_ref++;
  }
  else
  {
    k = new key (str, dcopy);
    std::pair<const char *, key *> p (k->m_str, k);
    bool s = m_keystore.insert (p).second;
    KVR_ASSERT (s);
  }

  return k;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::_destroy_key (key *k)
{
  KVR_ASSERT (k);

  if ((--k->m_ref) == 0)
  {
    m_keystore.erase (k->m_str);
    delete k;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value_null (uint32_t parentType)
{
  value *v = new value (this, parentType);

  v->conv_null ();

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value_map (uint32_t parentType)
{
  value *v = new value (this, parentType);

  v->_conv_map ();

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value_array (uint32_t parentType)
{
  value *v = new value (this, parentType);

  v->_conv_array ();

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value (uint32_t parentType, int64_t number)
{
  value *v = new value (this, parentType);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_number_i ();
#endif
  v->set_number_i (number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////


kvr::value * kvr::_create_value (uint32_t parentType, double number)
{
  value *v = new value (this, parentType);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_number_f ();
#endif
  v->set_number_f (number);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value (uint32_t parentType, bool boolean)
{
  value *v = new value (this, parentType);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_boolean ();
#endif
  v->set_boolean (boolean);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::_create_value (uint32_t parentType, const char *str)
{
  KVR_ASSERT (str);

  value *v = new value (this, parentType);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  v->conv_string ();
#endif
  v->set_string (str);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::_destroy_value (uint32_t parentType, value *v)
{
  KVR_ASSERT (v);
  KVR_ASSERT ((v->m_flags & parentType) != 0);

  delete v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::_diff_set (value *set, value *rem, const value *og, const value *md, const char **path, const sz_t pathsz, sz_t pathcnt)
{
  KVR_ASSERT (set);

  if (og)
  {
    //////////////////////////////////
    if (md == NULL)
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);
      // add og to rem list

      value *v = this->_create_value_null (VALUE_FLAG_PARENT_ARRAY);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF        
      v->conv_string ();
#endif
      if (pathcnt == 1)
      {
        const char *pk = path [0];        
        v->set_string (pk);
      }
      else
      {
        sz_t pksz = 0;
        const char *pk = _create_path_key (path, pathcnt, &pksz);
        v->_move_string_dyn ((char *) pk, pksz);
      }

      rem->_push_v (v);
    }

    //////////////////////////////////
    else if (!(og->is_number () && md->is_number ()) && (og->_type () != md->_type ()))
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);
      
#if 1 // optimization
      key *k = NULL;
      if ((pathcnt == 1) && (og->m_ctx == this)) // path key must already be in the key store
      {
        const char *pk = path [0];
        KVR_ASSERT (this->_find_key (pk));
        k = this->_create_key (pk); // increment reference count
      }
      else
      {
        const char *pk = _create_path_key (path, pathcnt);
        k = this->_create_key (pk, false);
        if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
      }
#else
      const char *pk = _create_path_key (path, pathcnt);
      key *k = this->_create_key (pk, false);
      if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
#endif
      value *v = this->_create_value_null (VALUE_FLAG_PARENT_MAP);
      v->copy (md);

      set->_insert_kv (k, v);
    }

    //////////////////////////////////
    else if (og->is_map ()) 
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_map ());

      value::cursor c = og->fcursor ();
      pair  *ogp = c.get_pair ();

      while (ogp)
      {
        const char *k = ogp->get_key ();        

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;

        pair * mdp = md->find (k);

        value *mdv = mdp ? mdp->get_value () : NULL;
        value *ogv = ogp->get_value ();

        _diff_set (set, rem, ogv, mdv, path, pathsz, pathcnt);
        
        path [--pathcnt] = NULL;

        ogp = c.get_pair ();
      }
    }

    //////////////////////////////////
    else if (og->is_array ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_array ());

      char k [16];

      for (sz_t i = 0, c = og->size (); i < c; ++i)
      {
        snprintf (k, 16, "%u", i);

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;
        
        value *mdv = md->element (i);
        value *ogv = og->element (i);

        _diff_set (set, rem, ogv, mdv, path, pathsz, pathcnt);
        
        path [--pathcnt] = NULL;
      }
    }

    //////////////////////////////////
    else if (og->is_string ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_string ());

      const char *ogstr = og->get_string ();
      const char *mdstr = md->get_string ();

      if (strcmp (ogstr, mdstr) != 0)
      {
        key *k = NULL;
        if ((pathcnt == 1) && (og->m_ctx == this)) // path key must already be in the key store
        {
          const char *pk = path [0];
          KVR_ASSERT (this->_find_key (pk));
          k = this->_create_key (pk); // increment reference count
        }
        else
        {
          const char *pk = _create_path_key (path, pathcnt);
          k = this->_create_key (pk, false);
          if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
        }

        value *v = this->_create_value (VALUE_FLAG_PARENT_MAP, mdstr);

        set->_insert_kv (k, v);
      }
    }

    //////////////////////////////////
    else if (og->_is_number_integer ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_number ());

      if (md->_is_number_integer ())
      {
        int64_t ogn = og->get_number_i ();
        int64_t mdn = md->get_number_i ();

        if (ogn != mdn)
        {
          key *k = NULL;
          if ((pathcnt == 1) && (og->m_ctx == this))
          {
            const char *pk = path [0];
            KVR_ASSERT (this->_find_key (pk));
            k = this->_create_key (pk); 
          }
          else
          {
            const char *pk = _create_path_key (path, pathcnt);
            k = this->_create_key (pk, false);            
            if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
          }         
      
          value *v = this->_create_value (VALUE_FLAG_PARENT_MAP, mdn);

          set->_insert_kv (k, v);
        }
      }
      else if (md->_is_number_float ())
      {
        double ogn = og->get_number_f ();
        double mdn = md->get_number_f ();

        if (fabs (ogn - mdn) > KVR_CONSTANT_ZERO_TOLERANCE)
        {
          key *k = NULL;
          if ((pathcnt == 1) && (og->m_ctx == this)) 
          {
            const char *pk = path [0];
            KVR_ASSERT (this->_find_key (pk));
            k = this->_create_key (pk);
          }
          else
          {
            const char *pk = _create_path_key (path, pathcnt);
            k = this->_create_key (pk, false);
            if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
          }

          value *v = this->_create_value (VALUE_FLAG_PARENT_MAP, mdn);
          
          set->_insert_kv (k, v);
        }
      }
    }

    //////////////////////////////////
    else if (og->_is_number_float ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_number ());

      double ogn = og->get_number_f ();
      double mdn = md->get_number_f ();

      if (fabs (ogn - mdn) > KVR_CONSTANT_ZERO_TOLERANCE)
      {
        key *k = NULL;
        if ((pathcnt == 1) && (og->m_ctx == this)) 
        {
          const char *pk = path [0];
          KVR_ASSERT (this->_find_key (pk));
          k = this->_create_key (pk); 
        }
        else
        {
          const char *pk = _create_path_key (path, pathcnt);
          k = this->_create_key (pk, false);
          if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
        }

        value *v = this->_create_value (VALUE_FLAG_PARENT_MAP, mdn);

        set->_insert_kv (k, v);
      }
    }

    //////////////////////////////////
    else if (og->is_boolean ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_boolean ());

      bool ogb = og->get_boolean ();
      bool mdb = md->get_boolean ();

      if (ogb != mdb)
      {
        key *k = NULL;
        if ((pathcnt == 1) && (og->m_ctx == this))
        {
          const char *pk = path [0];
          KVR_ASSERT (this->_find_key (pk));
          k = this->_create_key (pk); 
        }
        else
        {
          const char *pk = _create_path_key (path, pathcnt);
          k = this->_create_key (pk, false);
          if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
        }

        value *v = this->_create_value (VALUE_FLAG_PARENT_MAP, mdb);

        set->_insert_kv (k, v);
      }
    }

    //////////////////////////////////
    else if (og->is_null ())
    //////////////////////////////////
    {
      KVR_ASSERT (md->is_null ());
      // should already be taken care of in type check
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::_diff_add (value *add, const value *og, const value *md, const char **path, const sz_t pathsz, sz_t pathcnt)
{
  KVR_ASSERT (add);

  //
  // go through md and og and look for nodes in md that are not in og

  if (md)
  {
    //////////////////////////////////
    if (og == NULL)
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);
      // add md to add list

      key *k = NULL;
      if ((pathcnt == 1) && (md->m_ctx == this))
      {
        const char *pk = path [0];
        KVR_ASSERT (this->_find_key (pk));
        k = this->_create_key (pk);
      }
      else
      {
        const char *pk = _create_path_key (path, pathcnt);
        k = this->_create_key (pk, false);
        if (k->m_ref > 1) { _destroy_path_key (pk); pk = NULL; }
      }

      value *v = this->_create_value_null (VALUE_FLAG_PARENT_MAP);
      v->copy (md);

      add->_insert_kv (k, v);
    }

    //////////////////////////////////
    else if (og->_type () != md->_type ())
    //////////////////////////////////
    {
      // at this point og and md cannot be root values. therefore KVR_ASSERT (pathsz > 0)
      KVR_ASSERT (pathcnt > 0);
      // handled by _diff_set
    }

    //////////////////////////////////
    else if (md->is_map ())
    //////////////////////////////////
    {
      KVR_ASSERT (og->is_map ());

      value::cursor c = md->fcursor ();
      pair  *mdp = c.get_pair ();

      while (mdp)
      {
        const char *k = mdp->get_key ();

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;

        pair * ogp = og->find (k);

        value *ogv = ogp ? ogp->get_value () : NULL;
        value *mdv = mdp->get_value ();

        _diff_add (add, ogv, mdv, path, pathsz, pathcnt);

        path [--pathcnt] = NULL;

        mdp = c.get_pair ();
      }
    }

    //////////////////////////////////
    else if (md->is_array ())
    //////////////////////////////////
    {
      KVR_ASSERT (og->is_array ());

      char k [16];

      for (sz_t i = 0, c = md->size (); i < c; ++i)
      {
        snprintf (k, 16, "%u", i);

        KVR_ASSERT (pathcnt < pathsz);
        path [pathcnt++] = k;

        value *ogv = og->element (i);
        value *mdv = md->element (i);

        _diff_add (add, ogv, mdv, path, pathsz, pathcnt);

        path [--pathcnt] = NULL;
      }
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char * kvr::_create_path_key (const char **path, sz_t pathsz, sz_t *ksz) const
{
  KVR_ASSERT (pathsz > 0);

  char *pathkey = NULL;

  if (pathsz > 0)
  {
    // pre-calculate key buffer size
    sz_t keysz = 0;
    for (sz_t i = 0; i < pathsz; ++i)
    {
      const char *p = path [i];
      KVR_ASSERT (p);

      size_t plen = strlen (p);
      KVR_ASSERT (plen < MAX_SZ_T);

      keysz += (sz_t) plen;
      keysz += 1; // for delimiter/null character
    }

    if (keysz > 0)
    {
      // create key
      pathkey = new char [keysz];

      char *dst = pathkey;
      const char delim = KVR_CONSTANT_PATH_DELIMITER;

      for (sz_t i = 0; i < pathsz; ++i)
      {
        const char *p = path [i];
        KVR_ASSERT (p);

        while ((*dst++ = *p++)) {}
        *(dst - 1) = delim;
      }

      *(dst - 1) = 0;
    }

    if (ksz)
    {
      *ksz = keysz;
    }
  }

  return pathkey;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::_destroy_path_key (const char *key)
{
  delete [] key;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
// kvr::value
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::value (kvr *ctx, uint32_t flags) : m_flags (flags), m_ctx (ctx)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::~value () 
{
  this->_destruct (); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_null ()
{
  if (!is_null ())
  {
    this->_clear ();
    m_flags |= VALUE_FLAG_TYPE_NULL;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_map ()
{
  this->_conv_map ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_array ()
{
  this->_conv_array ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_string ()
{
  if (!is_string ())
  {
    this->_clear ();
    m_flags |= VALUE_FLAG_TYPE_STT_STRING;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_boolean ()
{
  if (!is_boolean ())
  {
    this->_clear ();
    m_flags |= VALUE_FLAG_TYPE_BOOLEAN;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_number_i ()
{
  if (!_is_number_integer ())
  {
    this->_clear ();
    m_flags |= VALUE_FLAG_TYPE_NUMBER_INTEGER;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::conv_number_f ()
{
  if (!_is_number_float ())
  {
    this->_clear ();
    m_flags |= VALUE_FLAG_TYPE_NUMBER_FLOAT;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_string (const char *str)
{
  KVR_ASSERT (str);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_string ());
#else
  conv_string ();
#endif

  size_t slen = strlen (str);
  
#if KVR_DEBUG
  KVR_ASSERT ((uint64_t) slen < kvr::MAX_SZ_T);
#endif
  
  sz_t size = (sz_t) slen;

  // check string type
  if (_is_string_static () && (size >= string::stt_str::CAP))
  {
    // init dynamic with size
    char *&sdata = m_data.s.m_dyn.data;
    sz_t &ssize = m_data.s.m_dyn.size;

    sz_t allocsz = (size + (string::dyn_str::PAD - 1)) & ~(string::dyn_str::PAD - 1);
    sdata = new char [allocsz];
    ssize = allocsz;
    
    // toggle string types
    m_flags &= ~VALUE_FLAG_TYPE_STT_STRING;
    m_flags |= VALUE_FLAG_TYPE_DYN_STRING;
  }
  
  // set string
  if (_is_string_dynamic ())
  {
    this->_set_string_dyn (str, size + 1);
  }
  else
  {
    this->_set_string_stt (str);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_boolean (bool b)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_boolean ());
#else
  conv_boolean ();
#endif
  
  m_data.b = b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_number_i (int64_t n)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_number_integer ());
#else  
  conv_number_i ();
#endif

  m_data.n.i = n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::set_number_f (double n)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_number_float ());
#else  
  conv_number_f ();
#endif

  m_data.n.f = n;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const char * kvr::value::get_string () const
{
  KVR_ASSERT (is_string ());
  return _is_string_dynamic () ? m_data.s.m_dyn.data : m_data.s.m_stt.data;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::get_boolean () const
{
  KVR_ASSERT (is_boolean ());
  return m_data.b;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

int64_t kvr::value::get_number_i () const
{
  KVR_ASSERT (is_number ());
  return _is_number_integer () ? m_data.n.i : (int64_t) m_data.n.f;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

double kvr::value::get_number_f () const
{
  KVR_ASSERT (is_number ());
  return _is_number_float () ? m_data.n.f : (double) m_data.n.i;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::sz_t kvr::value::size () const
{
  KVR_ASSERT (is_array () || is_map ());

  sz_t size = 0;

  if (is_array ())
  {
    size = this->m_data.a.m_len;
  }
  else if (is_map ())
  {
    size = this->m_data.m.m_size;
  }

  return size;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (int64_t number)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else  
  _conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, number);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (double number)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_array ());
#else
  _conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, number);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (bool boolean)
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else  
  _conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, boolean);  
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push (const char *str)
{
  KVR_ASSERT (str);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  _conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_ARRAY, str);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_map ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF  
  KVR_ASSERT (is_array ());
#else
  _conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_map (VALUE_FLAG_PARENT_ARRAY);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_array ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  _conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_array (VALUE_FLAG_PARENT_ARRAY);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::push_null ()
{
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_array ());
#else
  _conv_array ();
#endif

  kvr::value *v = m_ctx->_create_value_null (VALUE_FLAG_PARENT_ARRAY);
  this->m_data.a.push (v);

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::pop ()
{
  KVR_ASSERT (is_array ());

  bool ret = false;

  kvr::value *v = this->m_data.a.pop ();
  if (v)
  {
    m_ctx->_destroy_value (VALUE_FLAG_PARENT_ARRAY, v);
    ret = true;
  }

  return ret;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::element (kvr::sz_t index) const
{
  KVR_ASSERT (is_array ());

  value *v = this->m_data.a.m_ptr [index];

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, int64_t number)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (strlen (keystr) < KVR_CONSTANT_MAX_KEY_LENGTH);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  _conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->_create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    p->m_v->set_number_i (number);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, number);    
    p = m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, double number)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (strlen (keystr) < KVR_CONSTANT_MAX_KEY_LENGTH);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());  
#else
  _conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->_create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    p->m_v->set_number_f (number);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, number);    
    p = m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, bool boolean)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (strlen (keystr) < KVR_CONSTANT_MAX_KEY_LENGTH);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  _conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->_create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    p->m_v->set_boolean (boolean);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, boolean);    
    p = m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert (const char *keystr, const char *str)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (strlen (keystr) < KVR_CONSTANT_MAX_KEY_LENGTH);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  _conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->_create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);  
  if (p)
  {
    p->m_v->set_string (str);
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value (VALUE_FLAG_PARENT_MAP, str);    
    p = m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert_map (const char *keystr)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (strlen (keystr) < KVR_CONSTANT_MAX_KEY_LENGTH);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  _conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->_create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value_map (VALUE_FLAG_PARENT_MAP);    
    p = m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert_array (const char *keystr)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (strlen (keystr) < KVR_CONSTANT_MAX_KEY_LENGTH);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  _conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->_create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value_array (VALUE_FLAG_PARENT_MAP);    
    p = m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::insert_null (const char *keystr)
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (strlen (keystr) < KVR_CONSTANT_MAX_KEY_LENGTH);

#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
  KVR_ASSERT (is_map ());
#else
  _conv_map ();
#endif

  pair *p = NULL;

  key *k = m_ctx->_create_key (keystr);
  KVR_ASSERT (k);

#if !KVR_OPTIMIZATION_FAST_MAP_INSERT_ON
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  if (p)
  {
    m_ctx->_destroy_key (k);
  }
  else
#endif
  {
    value *v = m_ctx->_create_value_null (VALUE_FLAG_PARENT_MAP);    
    p = m_data.m.insert (k, v);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

bool kvr::value::remove (kvr::pair *pair)
{
  KVR_ASSERT (pair);
  KVR_ASSERT (is_map ());

  bool rm = false;

  key *k = pair->m_k;
  value *v = pair->m_v;

  if (m_data.m.remove (pair)) // mark k,v as null
  {
    m_ctx->_destroy_key (k);

    m_ctx->_destroy_value (VALUE_FLAG_PARENT_MAP, v);

    rm = true;
  }

  return rm;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::find (const char *keystr) const
{
  KVR_ASSERT (keystr);
  KVR_ASSERT (is_map ());

  pair *p = NULL;

  key *k = m_ctx->_find_key (keystr);

  if (k)
  {
    p = this->m_data.m.find (k);
  }

  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value::cursor kvr::value::fcursor () const
{
  KVR_ASSERT (is_map ());
  
  return cursor (&m_data.m);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::search (const char *path) const
{
  KVR_ASSERT (path);
  KVR_ASSERT (strlen (path) > 0);

  // TODO: convert path to unicode first

  value *v = (path [0] != 0) ? (value *) this : NULL;

  const char delim = KVR_CONSTANT_PATH_DELIMITER; 
  const char *p1 = path;
  const char *p2 = strchr (p1, delim);

  char key [KVR_CONSTANT_MAX_KEY_LENGTH + 1];

  while (v && p2)
  {
    sz_t klen = p2 - p1;
    KVR_ASSERT (klen <= KVR_CONSTANT_MAX_KEY_LENGTH);
    kvr_strncpy (key, p1, klen);
    
    v = v->_search_key (key);

    p1 = ++p2;
    p2 = strchr (p1, delim);
  }

  if (v && p1 && (*p1 != 0))
  {
    kvr_strcpy (key, KVR_CONSTANT_MAX_KEY_LENGTH, p1);

    v = v->_search_key (key);
  }

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::search (const char **path, sz_t pathsz) const
{
  KVR_ASSERT (path);
  KVR_ASSERT (pathsz > 0);

  value *v = (pathsz > 0) ? (value *) this : NULL;

  sz_t pc = 0;

  while (v && (pc < pathsz))
  {
    const char *key = path [pc++];

    v = v->_search_key (key);
  }

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::copy (const value *rhs)
{
  KVR_ASSERT (rhs);

  if (this != rhs)
  {
    //////////////////////////////////
    if (rhs->is_map ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->_conv_map (rhs->size ());
#endif
      cursor c = rhs->fcursor ();
      pair  *rp = c.get_pair ();
      while (rp)
      {
        const char *rk = rp->get_key ();
        pair *lp = this->insert_null (rk);

        value *rv = rp->get_value ();
        value *lv = lp->get_value ();
        lv->copy (rv);

        rp = c.get_pair ();
      }
    }

    //////////////////////////////////
    else if (rhs->is_array ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->_conv_array (rhs->size ());
#endif
      for (sz_t i = 0, c = rhs->size (); i < c; ++i)
      {
        value *rv = rhs->element (i);
        value *lv = this->push_null ();
        lv->copy (rv);
      }
    }

    //////////////////////////////////
    else if (rhs->is_string ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_string ();
#endif
      const char *str = rhs->get_string ();
      this->set_string (str);
    }

    //////////////////////////////////
    else if (rhs->_is_number_integer ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_number_i ();
#endif
      int64_t n = rhs->get_number_i ();
      this->set_number_i (n);
    }

    //////////////////////////////////
    else if (rhs->_is_number_float ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_number_f ();
#endif
      double n = rhs->get_number_f ();
      this->set_number_f (n);
    }

    //////////////////////////////////
    else if (rhs->is_boolean ())
    //////////////////////////////////
    {
#if KVR_OPTIMIZATION_IMPLICIT_TYPE_CONVERSION_OFF
      this->conv_boolean ();
#endif
      bool b = rhs->get_boolean ();
      this->set_boolean (b);
    }

    //////////////////////////////////
    else if (rhs->is_null ())
    //////////////////////////////////
    {
      this->conv_null ();
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::dump () const
{
  this->_dump (0, NULL);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_conv_map (sz_t size)
{
  if (!is_map ())
  {
    this->_clear ();
    m_flags |= VALUE_FLAG_TYPE_MAP;
    m_data.m.init (size);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_conv_array (sz_t size)
{
  if (!is_array ())
  {
    this->_clear ();
    m_flags |= VALUE_FLAG_TYPE_ARRAY;
    m_data.a.init (size);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_set_string_stt (const char *str)
{
  KVR_ASSERT (str);

  kvr_strcpy (m_data.s.m_stt.data, string::stt_str::CAP, str);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_set_string_dyn (const char *str, sz_t size)
{
  KVR_ASSERT (str);
  KVR_ASSERT (size > 0);

  char *&sdata = m_data.s.m_dyn.data;
  sz_t &ssize = m_data.s.m_dyn.size;

  sz_t allocsz = (size + (string::dyn_str::PAD - 1)) & ~(string::dyn_str::PAD - 1);
  if (allocsz > ssize)
  {
    KVR_ASSERT (sdata);
    delete [] sdata;
    sdata = new char [allocsz];
    ssize = allocsz;
  }

  kvr_strcpy (sdata, ssize, str);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_move_string_dyn (char *str, sz_t size)
{
  char *&sdata = m_data.s.m_dyn.data;
  sz_t &ssize = m_data.s.m_dyn.size;

  if (_is_string_dynamic ())
  {
    delete [] sdata;
  }
  else
  {
    m_flags &= ~VALUE_FLAG_TYPE_STT_STRING;
    m_flags |= VALUE_FLAG_TYPE_DYN_STRING;
  }

  sdata = str;
  ssize = size;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::pair * kvr::value::_insert_kv (key *k, value *v)
{
  KVR_ASSERT (k);
  KVR_ASSERT (v);
  KVR_ASSERT (is_map ());

  pair *p = NULL;
  
#if KVR_DEBUG
  p = (k->m_ref <= 1) ? NULL : m_data.m.find (k);
  KVR_ASSERT (p == NULL);
#endif

  p = m_data.m.insert (k, v);
  
  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_push_v (value *v)
{
  KVR_ASSERT (v);
  KVR_ASSERT (is_array ());

  this->m_data.a.push (v);  
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

kvr::value * kvr::value::_search_key (const char *key) const
{
  value *v = NULL;

  //////////////////////////////////
  if (this->is_map ())
  //////////////////////////////////
  {
    pair *p = this->find (key);
    v = p ? p->get_value () : NULL;
  }

  //////////////////////////////////
  else if (this->is_array ())
  //////////////////////////////////
  {
    char k0 = key [0];
    switch (k0)
    {
      case '*': // reserved for basic pattern matching
      {
        v = NULL;
        break;
      }

      default:
      {
        sz_t ki = (sz_t) atoi (key);
        v = this->element (ki);
        break;
      }
    }
  }

  return v;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_dump (size_t lpad, const char *key) const
{
  for (size_t t = 0; t < lpad; ++t)
  {
    fprintf (stderr, "  ");
  }

  if (key)
  {
    fprintf (stderr, "key = %s : ", key);
  }

  //////////////////////////////////
  if (this->is_map ())
  //////////////////////////////////
  {
    fprintf (stderr, "value = -> [map]\n");

    cursor c = fcursor ();
    pair  *p = c.get_pair ();
    while (p)
    {
      const char *k = p->get_key ();
      value *v = p->get_value ();
      v->_dump (lpad + 1, k);

      p = c.get_pair ();
    }
  }

  //////////////////////////////////
  else if (this->is_array ())
  //////////////////////////////////
  {
    fprintf (stderr, "value = -> [array]\n");
    
    char k [16];

    for (sz_t i = 0, c = this->size (); i < c; ++i)
    {
      snprintf (k, 16, "%u", i);
      value *v = this->element (i);
      v->_dump (lpad + 1, k);
    }
  }

  //////////////////////////////////
  else if (this->is_string ())
  //////////////////////////////////
  {
    const char *str = get_string ();
    fprintf (stderr, "value = %s -> [string]\n", str);
  }

  //////////////////////////////////
  else if (this->_is_number_integer ())
  //////////////////////////////////
  {
    int64_t n = get_number_i ();
    fprintf (stderr, "value = %lld -> [int]\n", n);
  }

  //////////////////////////////////
  else if (this->_is_number_float ())
  //////////////////////////////////
  {
    double n = get_number_f ();
    fprintf (stderr, "value = %g -> [float]\n", n);
  }

  //////////////////////////////////
  else if (this->is_boolean ())
  //////////////////////////////////
  {
    bool b = get_boolean ();
    fprintf (stderr, "value = %s -> [bool]\n", b ? "true" : "false");
  }

  //////////////////////////////////
  else if (this->is_null ())
  //////////////////////////////////
  {
    fprintf (stderr, "value = %s -> [null]\n", "null");
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_destruct ()
{
  if (is_map ())
  {
    cursor c = fcursor ();
    pair  *p = c.get_pair ();
    while (p)
    {
      m_ctx->_destroy_key (p->m_k);
      m_ctx->_destroy_value (VALUE_FLAG_PARENT_MAP, p->m_v);
      p = c.get_pair ();
    }
    m_data.m.deinit ();
  }
  else if (is_array ())
  {
    sz_t c = this->size ();
    while (c)
    {
      this->pop ();
      c = this->size ();
    }
    m_data.a.deinit ();
  }
  else if (_is_string_dynamic ())
  {
    KVR_ASSERT (m_data.s.m_dyn.data);
    delete [] m_data.s.m_dyn.data;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

void kvr::value::_clear ()
{
  // release memory
  this->_destruct ();

  // zero data
  memset (&m_data, 0, sizeof (m_data));

  // clear type flag
  const uint32_t typeFlagsMask = 0xffffff00;
  m_flags &= typeFlagsMask;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

uint8_t kvr::value::_type () const
{
  const uint32_t typeFlagsMask = 0xffffff00;

  uint8_t t = m_flags & ~typeFlagsMask;

  return t;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
