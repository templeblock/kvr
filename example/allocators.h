/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

/*
* Copyright (c) 2015 Ubaka Onyechi
*
* kvr is free software distributed under the MIT license.
* See https://github.com/uonyx/kvr/blob/master/LICENSE for details.
*/

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef KVR_EXAMPLE_ALLOCATORS
#define KVR_EXAMPLE_ALLOCATORS

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#define KVR_EXAMPLE_HAVE_BOOST 0

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#include "../src/kvr.h"
#if KVR_EXAMPLE_HAVE_BOOST
#include <boost/pool/pool.hpp>
#endif

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
// a simple stack-memory-based bump allocator - 
// all memory is reserved upfront and release at the end
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

template<size_t MAX_MEMORY_SZ>
class bump_allocator : public kvr::allocator
{
public:

  // allocate: return memory if available
  void *allocate (size_t sz)
  {
    void *p = NULL;
    if ((m_ptr + sz) <= MAX_MEMORY_SZ)
    {
      p = &m_memory [m_ptr];
      m_ptr += sz;
    }
    return p;
  }

  // deallocate: do nothing
  void deallocate (void *p, size_t sz) {}

  // memory usage
  size_t get_memory_usage () const { return m_ptr; }

  // purge
  void purge_memory () { m_ptr = 0; }

  // constructor
  bump_allocator () : m_ptr (0) {}

private:

  uint8_t m_memory [MAX_MEMORY_SZ];
  size_t  m_ptr;
};

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
#if KVR_EXAMPLE_HAVE_BOOST
// a pool allocator (using boost.pool) optimized for kvr::value and kvr::key dynamic allocations
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

class pool_allocator : public kvr::allocator
{
public:

  // allocate
  void *allocate (size_t sz)
  {
    void *p = NULL;
    switch (sz)
    {
      case SIZE_VALUE: { p = m_pool_v.malloc (); break; }
      case SIZE_KEY: { p = m_pool_k.malloc (); break; }
      default: { p = std::malloc (sz); break; }
    }
    return p;
  }

  // deallocate
  void deallocate (void *p, size_t sz)
  {
    if (p)
    {
      switch (sz)
      {
        case SIZE_VALUE: { m_pool_v.free (p); break; }
        case SIZE_KEY: { m_pool_k.free (p); break; }
        default: { std::free (p); break; }
      }
    }
  }

  // constructor
  pool_allocator () : m_pool_v (SIZE_VALUE, 64), m_pool_k (SIZE_KEY, 64) {}

private:

  static const size_t SIZE_VALUE = sizeof (kvr::value);
  static const size_t SIZE_KEY = sizeof (kvr::key);

  boost::pool<boost::default_user_allocator_malloc_free>
    m_pool_v,
    m_pool_k;
};
#endif
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#endif

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
