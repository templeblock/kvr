/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

/*
* Copyright (c) 2015 Ubaka Onyechi
*
* kvr is free software distributed under the MIT license.
* See https://github.com/uonyx/kvr/blob/master/LICENSE for details.
*/

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef KVR_EXAMPLE_ALLOCATORS
#define KVR_EXAMPLE_ALLOCATORS

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#include "../src/kvr.h"
#ifdef KVR_EXAMPLE_HAVE_BOOST
#include <boost/pool/pool.hpp>
#endif

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
// an arena allocator using stack memory. memory is reserved during object construction 
// and released when out of scope. (useful for embedded systems)
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

template<size_t MAX_MEMORY_SZ>
class arena_allocator : public kvr::allocator
{
public:

  // allocate: return memory if available
  void *allocate (size_t sz)
  {
    void *p = NULL;
    if ((m_ptr + sz) <= MAX_MEMORY_SZ)
    {
      p = &m_memory [m_ptr];
      m_ptr += sz;
    }
    return p;
  }

  // deallocate: do nothing
  void deallocate (void *p, size_t sz) {(void) p; (void) sz;}

  // memory usage
  size_t get_memory_usage () const { return m_ptr; }

  // purge
  void purge_memory () { m_ptr = 0; }

  // constructor
  arena_allocator () : m_ptr (0) {}

private:

  uint8_t m_memory [MAX_MEMORY_SZ];
  size_t  m_ptr;
};

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef KVR_EXAMPLE_HAVE_BOOST
// a pool allocator optimized for kvr::value and kvr::key dynamic allocations
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

class pool_allocator : public kvr::allocator
{
public:

  // allocate
  void *allocate (size_t sz)
  {
    void *p = NULL;
    switch (sz)
    {
      case SIZE_VALUE:  { p = m_pool_v.malloc (); break; }
      case SIZE_KEY:    { p = m_pool_k.malloc (); break; }
      default:          { p = std::malloc (sz); break; }
    }
    return p;
  }

  // deallocate
  void deallocate (void *p, size_t sz)
  {
    if (p)
    {
      switch (sz)
      {
        case SIZE_VALUE:  { m_pool_v.free (p); break; }
        case SIZE_KEY:    { m_pool_k.free (p); break; }
        default:          { std::free (p); break; }
      }
    }
  }

  // constructor
  pool_allocator () : m_pool_v (SIZE_VALUE, 64), m_pool_k (SIZE_KEY, 64) {}

private:

  static const size_t SIZE_VALUE = sizeof (kvr::value);
  static const size_t SIZE_KEY = sizeof (kvr::key);

  boost::pool<boost::default_user_allocator_malloc_free>
    m_pool_v,
    m_pool_k;
};
#endif
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

#endif

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
